<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>oracle cloud free tier resource exhaustion bypass</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; }
        h1, h2, h3 { color: #111; text-transform: lowercase; }
        code { background: #f4f4f4; padding: 2px 5px; border-radius: 3px; font-family: monospace; }
        pre { background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto; }
        .mermaid { margin: 20px 0; text-align: center; }
        .date { color: #666; font-style: italic; }
        a { color: #0366d6; text-decoration: none; }
        a:hover { text-decoration: underline; }
        p, li { text-transform: lowercase; }
        .keep-case { text-transform: none; }
        img { max-width: 100%; border: 1px solid #ddd; border-radius: 4px; padding: 5px; }
        .caption { font-style: italic; color: #666; text-align: center; display: block; margin-top: 5px; font-size: 0.9em; }
    </style>
</head>
<body>

    <h1>oracle cloud free tier resource exhaustion bypass via autonomous api polling</h1>

    <p class="date"><strong>date:</strong> jan 29, 2026<br>
    <strong>topic:</strong> cloud automation, anti-fingerprinting, resource arbitration<br>
    <strong>classification:</strong> technical procedure / vulnerability disclosure</p>

    <hr>

    <h3>subject</h3>
    <p>oracle cloud's "out of host capacity" error (http 500) for free-tier arm instances (<span class="keep-case">vm.standard.a1.flex</span>) functions as a soft limit based on temporal resource contention rather than a hard account restriction. by implementing high-frequency, authenticated api polling coupled with identity-layer obfuscation (residential proxies and canvas fingerprint spoofing), users can exploit race conditions in the provisioning queue to secure maximum-spec instances (4 ocpus, 24gb ram) that are otherwise unavailable via the web console.</p>

    <hr>

    <h3>"capacity" lie</h3>
    <p>when a user attempts to create an arm instance in a popular region (ashburn, frankfurt, tokyo), the console almost invariably returns <code>500 internal server error: out of host capacity</code>.</p>

    <p>this is <strong>not</strong> a hard denial. it is a temporal state.</p>

    <ul>
        <li><strong>reality</strong>: capacity opens up constantly as other tenancies are terminated or hardware is added.</li>
        <li><strong>the flaw</strong>: the allocation logic is first-come-first-served (fcfs).</li>
        <li><strong>the exploit</strong>: a human cannot click fast enough to catch the 3-second window when a slot opens. an automated script polling every 60 seconds <strong>can</strong>.</li>
    </ul>

    <img src="images/error_screenshot.png" alt="oracle out of host capacity error">
    <span class="caption">the boss fight: oracle's polite way of saying "go away"</span>

    <div class="mermaid">
    graph td
        subgraph "the problem"
            user[me] -->|manual click| console["oracle console"]
            console -- "error: out of capacity" --x user
        end

        subgraph "the solution"
            nas["home nas"] -->|api poll 60s| api["oci api"]
            api -- "success 200 ok" --> instance["arm instance"]
            nas -- "ssh jump" --> instance
        end

        %% high contrast styling
        style instance fill:#ccffcc,stroke:#333,stroke-width:2px,color:black
        style console fill:#ff9999,stroke:#333,stroke-width:2px,color:black
    </div>

    <hr>

    <h3>details</h3>
    <p>the exploitation technique relies on three distinct phases: <strong>identity engineering</strong> (to create the account), <strong>autonomous sniping</strong> (to provision resources), and <strong>stealth access</strong> (to maintain the account).</p>

    <hr>

    <h3>phase 1: identity engineering (the "clean room")</h3>
    <p>before any automation can run, you must possess a valid oci account. this is the hardest step due to <strong>oracle adaptive access manager (oaam)</strong>.</p>

    <h4>the threat model</h4>
    <p>oaam aggregates data to generate a "fraud risk score":</p>

    <ul>
        <li><strong>browser fingerprint</strong>: canvas hash, audiocontext, webgl renderer, fonts.</li>
        <li><strong>network reputation</strong>: ip quality score, datacenter vs. residential, geo-velocity.</li>
        <li><strong>payment consistency</strong>: bin country vs. ip country.</li>
    </ul>

    <div class="mermaid">
    graph lr
        subgraph "my pc"
            browser["chrome (dirty identity)"]
            dolphin["dolphin{anty} (clean identity)"]
        end

        subgraph "network layer"
            isp["home isp ip"]
            proxy["residential proxy (catalonia)"]
        end

        subgraph "oracle oaam"
            checks["fingerprint + ip analysis"]
            decision{risk score}
        end

        browser -- "direct" --> isp --> checks
        dolphin -- "spoofed hardware" --> proxy --> checks

        checks --> decision
        decision -- "score > 80" --> ban["shadowban / error"]
        decision -- "score < 20" --> success["account created"]

        %% high contrast styling
        style ban fill:#ff9999,stroke:#333,stroke-width:2px,color:black
        style success fill:#ccffcc,stroke:#333,stroke-width:2px,color:black
    </div>

    <h4>the bypass procedure</h4>
    <p><strong>tools required:</strong></p>

    <ol>
        <li><strong>dolphin{anty}</strong>: anti-detect browser that spoofs hardware fingerprints.</li>
        <li><strong>residential proxy</strong>: rotating or sticky residential ips (not vpns/datacenter).</li>
        <li><strong>payment method</strong>: physical card (not virtual/prepaid) matching the proxy region.</li>
    </ol>

    <p><strong>steps:</strong></p>

    <ol>
        <li><strong>profile generation</strong>: in dolphin, create a new profile. set os to "windows" or "mac". the software generates unique, consistent noise for canvas/webgl to mimic a generic consumer device.</li>
    </ol>

    <img src="images/dolphin_config.jpg" alt="dolphin anty fingerprint config">
    <span class="caption">generating a new digital soul in dolphin</span>

    <ol start="2">
        <li><strong>network alignment</strong>: purchase a residential proxy (e.g., from <em>decodo</em> or similar providers). configure it as a <strong>sticky session</strong> (10-30 mins).
            <ul>
                <li><em>critical</em>: if the ip changes from madrid to barcelona during the credit card verification, the geo-velocity check fails -> account ban.</li>
            </ul>
        </li>
        <li><strong>execution</strong>: complete the signup flow inside this container. do not use your regular chrome/firefox.</li>
        <li><strong>verification</strong>: once the "welcome to oracle cloud" email arrives, the identity is established.</li>
    </ol>

    <img src="images/decodo_dashboard.png" alt="decodo receipt">
    <span class="caption">total cost: $4.84 ($4.00 + $0.84 (21% VAT). cheaper than a starbucks latte.</span>

    <hr>

    <h3>phase 2: the sniper (technical implementation)</h3>
    <p>this phase moves the battle from the browser to the api. we deploy a persistent python daemon on a local server (nas/raspberry pi) to handle the race condition.</p>

    <h4>1. environment preparation</h4>
    <p>the attack runs on a low-power linux host.</p>

    <p><strong>directory structure:</strong></p>
    <pre>/home/microck/oracle-sniper/
â”œâ”€â”€ main.py             # the logic core
â”œâ”€â”€ setup_init.sh       # process wrapper & monitoring
â”œâ”€â”€ oci.env             # secrets configuration
â”œâ”€â”€ oci_config          # oci sdk config
â”œâ”€â”€ oci_api_key.pem     # your private api key
â””â”€â”€ requirements.txt    # dependencies</pre>

    <h4>2. authentication setup (<code>oci_config</code>)</h4>
    <p>bypass the gui entirely. generate an api signing key in the oracle console (user settings -> api keys).</p>

    <p><strong>file: <code>oci_config</code></strong></p>
    <pre>[default]
user=ocid1.user.oc1..aaaa...
fingerprint=xx:xx:xx...
key_file=/home/microck/oracle-sniper/account_ashburn/oci_api_key.pem
tenancy=ocid1.tenancy.oc1..aaaa...
region=us-ashburn-1</pre>

    <h4>3. attack configuration (<code>oci.env</code>)</h4>
    <p>this file controls the sniper's targeting parameters.</p>

    <p><strong>file: <code>oci.env</code></strong></p>
    <pre># target definition
oci_compute_shape=vm.standard.a1.flex
# ubuntu 22.04 aarch64 image ocid (region specific!)
oci_image_id=ocid1.image.oc1.iad.aaaaaaaa...
ocpus=4
memory_in_gbs=24

# network targets
# must pre-create a vcn and subnet in the console!
oci_subnet_id=ocid1.subnet.oc1.iad.aaaaaaaa...
assign_public_ip=true

# attack frequency
# < 60s risks "toomanyrequests" (429) rate limiting
request_wait_time_secs=60

# notification channels
discord_webhook=https://discord.com/api/webhooks/...</pre>

    <h4>4. the logic core (<code>main.py</code>)</h4>
    <p>the script implements a specific state machine to handle oracle's error codes.</p>

    <p><strong>key logic: error handling</strong><br>
    oracle returns specific codes when capacity is full. the script must distinguish between "fatal error" (config wrong) and "soft error" (try again).</p>
    <pre><code>def handle_errors(command, data, log):
    # these are not failures. they are "wait" signals.
    soft_errors = [
        "toomanyrequests",
        "out of host capacity",
        "internalerror",
        "bad gateway"
    ]

    if data["code"] in soft_errors:
        log.info(f"soft limit hit: {data['code']}. sleeping...")
        time.sleep(wait_time)
        return true # retry allowed

    # anything else is a real crash
    raise exception(f"fatal error: {data}")
</code></pre>

    <p><strong>key logic: the launch loop</strong></p>
    <pre><code>def launch_instance():
    # loop until success
    while not instance_exist_flag:
        try:
            compute_client.launch_instance(...)
            # if we get here, we won.
            send_discord_message("ðŸŽ‰ sniped!")
            break
        except serviceerror as e:
            # handle the 500/429 errors
            handle_errors(...)
</code></pre>

    <img src="images/sniper_logs.jpg" alt="sniper logs success">
    <span class="caption">gotcha. the moment the sniper fired.</span>

    <h4>5. deployment</h4>
    <p>we use <code>nohup</code> (no hang up) to ensure the process survives ssh disconnection.</p>

    <p><strong>command:</strong></p>
    <pre>chmod +x setup_init.sh
./setup_init.sh</pre>

    <p><strong>monitoring logs:</strong></p>
    <pre>tail -f launch_instance.log</pre>

    <p><em>output (normal operation):</em></p>
    <pre>2026-01-25 22:11:03 - info - command: launch_instance-- output: {'status': 500, 'code': 'internalerror', 'message': 'out of host capacity.'}
2026-01-25 22:12:04 - info - command: launch_instance-- output: {'status': 500, 'code': 'internalerror', 'message': 'out of host capacity.'}</pre>

    <hr>

    <h3>phase 3: stealth access (post-exploitation)</h3>
    <p>once the instance creates, accessing it carelessly will get you banned. if your "identity" ip (spain proxy) created the account, but your "access" ip (home ip) logs in via ssh, oracle links the two.</p>

    <p><strong>the "clean" link:</strong><br>
    do not ssh directly. tunnel traffic through a neutral, trusted intermediary.</p>

    <p><strong>scenario:</strong></p>

    <ol>
        <li><strong>trusted host</strong>: existing <code>oracle-paris</code> instance (or any cheap vps).</li>
        <li><strong>target host</strong>: the new <code>oracle-ashburn</code> instance.</li>
    </ol>

    <p><strong>ssh config (<code>~/.ssh/config</code>):</strong></p>
    <pre># 1. the jump host (the mask)
host oracle-paris
    hostname 141.145.xxx.xxx
    user ubuntu
    identityfile ~/.ssh/id_rsa_paris

# 2. the target (hidden behind paris)
host oracle-ashburn
    hostname 10.0.0.x                # use private ip if vpn'd, or public ip
    user ubuntu
    proxyjump oracle-paris           # <--- the key
    identityfile ~/.ssh/id_rsa_ashburn</pre>

    <p><strong>traffic flow:</strong><br>
    <code>home pc</code> -> (encrypted) -> <code>paris vps</code> -> (encrypted) -> <code>ashburn instance</code></p>

    <p>to oracle's logs in ashburn, the connection comes from the paris ip, not your home ip.</p>

    <hr>

    <h3>evidence of success</h3>
    <p>retrieving logs from the nas confirms the methodology works.</p>

    <p><strong>file: <code>instance_created</code></strong></p>
    <pre>instance id: ocid1.instance.oc1.iad.anuwcljt6jdfblacplxseahalwablmit2csfvgj3gx47n5npd23d5zwnuega
display name: ashburn-sniper-instance
availability domain: mnay:us-ashburn-ad-1
shape: vm.standard.a1.flex
state: provisioning</pre>

    <p>the script successfully negotiated the race condition, provisioned the resource, and alerted the user via discord.</p>

    <img src="images/console_victory.jpg" alt="oracle console login">
    <span class="caption">in. account created successfully. the sniper is now active.</span>

    <hr>

    <h3>recommendations</h3>
    <p>to mitigate this exhaustion and evasion technique, cloud providers should:</p>

    <ol>
        <li><strong>implement proof-of-work (pow)</strong>: require a computational puzzle (hashcash style) for <code>launch_instance</code> api calls on free-tier tenancies. this makes high-frequency polling computationally expensive for the attacker.</li>
        <li><strong>link billing to access</strong>: correlate login/api ip addresses with billing geography post-creation, not just during signup.</li>
        <li><strong>waitlist queue</strong>: replace "first-come-first-served" 500 errors with a verified waitlist system for high-demand shapes.</li>
    </ol>

    <hr>

    <h3>references</h3>
    <ul>
        <li><a href="https://github.com/oracle/oci-python-sdk">oracle cloud infrastructure python sdk</a></li>
        <li><a href="https://docs.oracle.com/cd/e23943_01/doc.1111/e15740/oaam.htm">oaam (oracle adaptive access manager) documentation</a></li>
        <li><a href="https://anty.dolphin.ru.com">dolphin{anty} anti-detect browser</a></li>
    </ul>

    <script>mermaid.initialize({startOnLoad:true});</script>
</body>
</html>
